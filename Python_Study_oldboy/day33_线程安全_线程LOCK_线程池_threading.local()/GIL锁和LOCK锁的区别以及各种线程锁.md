# 网址:https://www.cnblogs.com/zwq-/p/9621275.html

# 线程安全和非线程安全
        ## 线程安全:是指在多线程环境下也不会出现数据不一致。queue
        ## 非线程安全：是指在多线程环境下有可能出现数据不一致的情况。

# GIL锁----全局解释器锁
        ## 在同一个进程中只要有一个线程获取了全局解释器（cpu）的使用权限，那么其他的线程就必须等待该线程的全局解释器（cpu）使用权消失后才       能使用全局解释器（cpu）,即使多个线程直接不会相互影响在同一个进程下也只有一个线程使用cpu，这样的机制称为全局解释器锁（GIL）
        ## 同一时刻的某个进程下只有一个线程被一个cpu所处理，所以在GIL锁下的线程只能被并发(多个线程被一个Cpu按照时间片来轮流调用执行)，          不能被并行(多个线程同时被多个CPU调用执行)。

    ## 执行过程：线程1抢到GIL锁，拿到执行权限，开始执行，然后加了一把Lock，还没有执行完毕，即线程1还未释放Lock，有可能线程2抢到GIL锁，开始执行，执行过程中发现Lock还没有被线程1释放，于是线程2进入阻塞，被夺走执行权限，有可能线程1拿到GIL，然后正常执行到释放Lock。。。

# LOCK锁----通常被用来实现对共享资源的同步访问。
        ## 在多线程程序中，由于CPU在执行100个指令后会切换线程，因此在多个线程对公共数据进行操作时，会由于线程的切换导致公共数据的混乱，因此为了防止“脏数据”的出现，在多线程操作公共数据的代码段人为加LOCK.

    ## 执行过程：为每一个共享资源创建一个Lock对象，当你需要访问该资源时，调用acquire方法来获取锁对象（如果其它线程已经获得了该锁，则当前线程需等待其被释放），待公共资源访问完后，再调用release方法释放锁：

# Lock锁的分类
        ## Lock互斥锁(一次解锁一个线程)，python 3.7.4 版本中已经没有该锁，此锁不能嵌套(Lock里面嵌套Lock)

        ## RLock递归锁(一次解锁一个线程)，Rlock锁可以嵌套：
                ### 每个thread都运行f()，f()获取锁后，运行g()，但g()中也需要获取同一个锁。如果用Lock，这里多次获取锁，就发生了死锁。但          我们代码中使用了RLock。在同一线程内，对RLock进行多次acquire()操作，程序不会堵塞
                ### 用法：
                        #### 1、lock.acquire()--加锁  lock.release()--解锁
                        #### 2、with lock:
                        ####      pass

        ## BoundedSemaphore 信号量(一次解锁固定数量线程) Bounded--限定  Semaphore--信号

        ## condition 条件锁(解锁用户输入数量的线程) condition--条件